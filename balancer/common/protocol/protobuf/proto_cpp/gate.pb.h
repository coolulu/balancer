// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gate.proto

#ifndef PROTOBUF_gate_2eproto__INCLUDED
#define PROTOBUF_gate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
namespace gate {
class CloseClientReq;
class CloseClientReqDefaultTypeInternal;
extern CloseClientReqDefaultTypeInternal _CloseClientReq_default_instance_;
class CloseClientRsp;
class CloseClientRspDefaultTypeInternal;
extern CloseClientRspDefaultTypeInternal _CloseClientRsp_default_instance_;
class CloseConnIdReq;
class CloseConnIdReqDefaultTypeInternal;
extern CloseConnIdReqDefaultTypeInternal _CloseConnIdReq_default_instance_;
class CloseConnIdRsp;
class CloseConnIdRspDefaultTypeInternal;
extern CloseConnIdRspDefaultTypeInternal _CloseConnIdRsp_default_instance_;
class GateMsg;
class GateMsgDefaultTypeInternal;
extern GateMsgDefaultTypeInternal _GateMsg_default_instance_;
class GetConnIdReq;
class GetConnIdReqDefaultTypeInternal;
extern GetConnIdReqDefaultTypeInternal _GetConnIdReq_default_instance_;
class GetConnIdRsp;
class GetConnIdRspDefaultTypeInternal;
extern GetConnIdRspDefaultTypeInternal _GetConnIdRsp_default_instance_;
class LogoutReq;
class LogoutReqDefaultTypeInternal;
extern LogoutReqDefaultTypeInternal _LogoutReq_default_instance_;
class LogoutRsp;
class LogoutRspDefaultTypeInternal;
extern LogoutRspDefaultTypeInternal _LogoutRsp_default_instance_;
class SetConnLoginReq;
class SetConnLoginReqDefaultTypeInternal;
extern SetConnLoginReqDefaultTypeInternal _SetConnLoginReq_default_instance_;
class SetConnLoginRsp;
class SetConnLoginRspDefaultTypeInternal;
extern SetConnLoginRspDefaultTypeInternal _SetConnLoginRsp_default_instance_;
class WakeHeartbeatReq;
class WakeHeartbeatReqDefaultTypeInternal;
extern WakeHeartbeatReqDefaultTypeInternal _WakeHeartbeatReq_default_instance_;
class WakeHeartbeatRsp;
class WakeHeartbeatRspDefaultTypeInternal;
extern WakeHeartbeatRspDefaultTypeInternal _WakeHeartbeatRsp_default_instance_;
}  // namespace gate

namespace gate {

namespace protobuf_gate_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_gate_2eproto

enum ErrorCode {
  SUCCESS = 0,
  ERR_SYS_BEGIN = 103000100,
  ERR_SYS_OVERLOAD = 103000101,
  ERR_SYS_REJECT_SERVICE = 103000102,
  ERR_SYS_SERVER_INNER = 103000103,
  ERR_SYS_TIMEOUT = 103000104,
  ERR_SYS_NO_INSERVICE_LIST = 103000105,
  ERR_SYS_TASK_STATE = 103000106,
  ERR_SYS_TASK_DISCARD = 103000107,
  ERR_SYS_END = 103000199,
  ERR_PACKET_BEGIN = 103000200,
  ERR_PACKET_ENCODE = 103000201,
  ERR_PACKET_DECODE = 103000202,
  ERR_PACKET_HEADER = 103000203,
  ERR_PACKET_LEN = 103000204,
  ERR_PACKET_VERSION = 103000205,
  ERR_PACKET_FROM_SERVICE_ID = 103000206,
  ERR_PACKET_TO_SERVICE_ID = 103000207,
  ERR_PACKET_APP_ID = 103000208,
  ERR_PACKET_APP_VERSION = 103000209,
  ERR_PACKET_CONN_SEQ_ID = 103000210,
  ERR_PACKET_MSG_SEQ_ID = 103000211,
  ERR_PACKET_DATA_FORMAT = 103000212,
  ERR_PACKET_DATA_FIELD_0 = 103000213,
  ERR_PACKET_DATA_FIELD_1 = 103000214,
  ERR_PACKET_DATA_FIELD_2 = 103000215,
  ERR_PACKET_DATA_FIELD_3 = 103000216,
  ERR_PACKET_CHECK_SUM = 103000217,
  ERR_PACKET_UNKNOWN_REQUEST = 103000218,
  ERR_PACKET_END = 103000299,
  ERR_INTERFACE_BEGIN = 103000300,
  ERR_INTERFACE_PARAM = 103000301,
  ERR_INTERFACE_PERM = 103000302,
  ERR_INTERFACE_TIMEOUT = 103000303,
  ERR_INTERFACE_END = 103000399,
  ERR_BUSINESS_BEGIN = 103001000,
  ERR_BUSINESS_NOT_FIND_CONN_ID = 103001001,
  ERR_BUSINESS_END = 103009999,
  ErrorCode_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ErrorCode_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ErrorCode_IsValid(int value);
const ErrorCode ErrorCode_MIN = SUCCESS;
const ErrorCode ErrorCode_MAX = ERR_BUSINESS_END;
const int ErrorCode_ARRAYSIZE = ErrorCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorCode_descriptor();
inline const ::std::string& ErrorCode_Name(ErrorCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorCode_descriptor(), value);
}
inline bool ErrorCode_Parse(
    const ::std::string& name, ErrorCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorCode>(
    ErrorCode_descriptor(), name, value);
}
// ===================================================================

class GateMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GateMsg) */ {
 public:
  GateMsg();
  virtual ~GateMsg();

  GateMsg(const GateMsg& from);

  inline GateMsg& operator=(const GateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GateMsg(GateMsg&& from) noexcept
    : GateMsg() {
    *this = ::std::move(from);
  }

  inline GateMsg& operator=(GateMsg&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GateMsg& default_instance();

  enum ChoiceCase {
    kTestReq = 1,
    kTestRsp = 2,
    kWakeHeartbeatReq = 3,
    kWakeHeartbeatRsp = 4,
    kGetConnIdReq = 5,
    kGetConnIdRsp = 6,
    kCloseConnIdReq = 7,
    kCloseConnIdRsp = 8,
    kCloseClientReq = 9,
    kCloseClientRsp = 10,
    kLogoutReq = 11,
    kLogoutRsp = 12,
    kSetConnLoginReq = 13,
    kSetConnLoginRsp = 14,
    CHOICE_NOT_SET = 0,
  };

  static inline const GateMsg* internal_default_instance() {
    return reinterpret_cast<const GateMsg*>(
               &_GateMsg_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(GateMsg* other);
  friend void swap(GateMsg& a, GateMsg& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GateMsg* New() const PROTOBUF_FINAL { return New(NULL); }

  GateMsg* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GateMsg& from);
  void MergeFrom(const GateMsg& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GateMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .common.TestReq test_req = 1;
  bool has_test_req() const;
  void clear_test_req();
  static const int kTestReqFieldNumber = 1;
  const ::common::TestReq& test_req() const;
  ::common::TestReq* mutable_test_req();
  ::common::TestReq* release_test_req();
  void set_allocated_test_req(::common::TestReq* test_req);

  // .common.TestRsp test_rsp = 2;
  bool has_test_rsp() const;
  void clear_test_rsp();
  static const int kTestRspFieldNumber = 2;
  const ::common::TestRsp& test_rsp() const;
  ::common::TestRsp* mutable_test_rsp();
  ::common::TestRsp* release_test_rsp();
  void set_allocated_test_rsp(::common::TestRsp* test_rsp);

  // .gate.WakeHeartbeatReq wake_heartbeat_req = 3;
  bool has_wake_heartbeat_req() const;
  void clear_wake_heartbeat_req();
  static const int kWakeHeartbeatReqFieldNumber = 3;
  const ::gate::WakeHeartbeatReq& wake_heartbeat_req() const;
  ::gate::WakeHeartbeatReq* mutable_wake_heartbeat_req();
  ::gate::WakeHeartbeatReq* release_wake_heartbeat_req();
  void set_allocated_wake_heartbeat_req(::gate::WakeHeartbeatReq* wake_heartbeat_req);

  // .gate.WakeHeartbeatRsp wake_heartbeat_rsp = 4;
  bool has_wake_heartbeat_rsp() const;
  void clear_wake_heartbeat_rsp();
  static const int kWakeHeartbeatRspFieldNumber = 4;
  const ::gate::WakeHeartbeatRsp& wake_heartbeat_rsp() const;
  ::gate::WakeHeartbeatRsp* mutable_wake_heartbeat_rsp();
  ::gate::WakeHeartbeatRsp* release_wake_heartbeat_rsp();
  void set_allocated_wake_heartbeat_rsp(::gate::WakeHeartbeatRsp* wake_heartbeat_rsp);

  // .gate.GetConnIdReq get_conn_id_req = 5;
  bool has_get_conn_id_req() const;
  void clear_get_conn_id_req();
  static const int kGetConnIdReqFieldNumber = 5;
  const ::gate::GetConnIdReq& get_conn_id_req() const;
  ::gate::GetConnIdReq* mutable_get_conn_id_req();
  ::gate::GetConnIdReq* release_get_conn_id_req();
  void set_allocated_get_conn_id_req(::gate::GetConnIdReq* get_conn_id_req);

  // .gate.GetConnIdRsp get_conn_id_rsp = 6;
  bool has_get_conn_id_rsp() const;
  void clear_get_conn_id_rsp();
  static const int kGetConnIdRspFieldNumber = 6;
  const ::gate::GetConnIdRsp& get_conn_id_rsp() const;
  ::gate::GetConnIdRsp* mutable_get_conn_id_rsp();
  ::gate::GetConnIdRsp* release_get_conn_id_rsp();
  void set_allocated_get_conn_id_rsp(::gate::GetConnIdRsp* get_conn_id_rsp);

  // .gate.CloseConnIdReq close_conn_id_req = 7;
  bool has_close_conn_id_req() const;
  void clear_close_conn_id_req();
  static const int kCloseConnIdReqFieldNumber = 7;
  const ::gate::CloseConnIdReq& close_conn_id_req() const;
  ::gate::CloseConnIdReq* mutable_close_conn_id_req();
  ::gate::CloseConnIdReq* release_close_conn_id_req();
  void set_allocated_close_conn_id_req(::gate::CloseConnIdReq* close_conn_id_req);

  // .gate.CloseConnIdRsp close_conn_id_rsp = 8;
  bool has_close_conn_id_rsp() const;
  void clear_close_conn_id_rsp();
  static const int kCloseConnIdRspFieldNumber = 8;
  const ::gate::CloseConnIdRsp& close_conn_id_rsp() const;
  ::gate::CloseConnIdRsp* mutable_close_conn_id_rsp();
  ::gate::CloseConnIdRsp* release_close_conn_id_rsp();
  void set_allocated_close_conn_id_rsp(::gate::CloseConnIdRsp* close_conn_id_rsp);

  // .gate.CloseClientReq close_client_req = 9;
  bool has_close_client_req() const;
  void clear_close_client_req();
  static const int kCloseClientReqFieldNumber = 9;
  const ::gate::CloseClientReq& close_client_req() const;
  ::gate::CloseClientReq* mutable_close_client_req();
  ::gate::CloseClientReq* release_close_client_req();
  void set_allocated_close_client_req(::gate::CloseClientReq* close_client_req);

  // .gate.CloseClientRsp close_client_rsp = 10;
  bool has_close_client_rsp() const;
  void clear_close_client_rsp();
  static const int kCloseClientRspFieldNumber = 10;
  const ::gate::CloseClientRsp& close_client_rsp() const;
  ::gate::CloseClientRsp* mutable_close_client_rsp();
  ::gate::CloseClientRsp* release_close_client_rsp();
  void set_allocated_close_client_rsp(::gate::CloseClientRsp* close_client_rsp);

  // .gate.LogoutReq logout_req = 11;
  bool has_logout_req() const;
  void clear_logout_req();
  static const int kLogoutReqFieldNumber = 11;
  const ::gate::LogoutReq& logout_req() const;
  ::gate::LogoutReq* mutable_logout_req();
  ::gate::LogoutReq* release_logout_req();
  void set_allocated_logout_req(::gate::LogoutReq* logout_req);

  // .gate.LogoutRsp logout_rsp = 12;
  bool has_logout_rsp() const;
  void clear_logout_rsp();
  static const int kLogoutRspFieldNumber = 12;
  const ::gate::LogoutRsp& logout_rsp() const;
  ::gate::LogoutRsp* mutable_logout_rsp();
  ::gate::LogoutRsp* release_logout_rsp();
  void set_allocated_logout_rsp(::gate::LogoutRsp* logout_rsp);

  // .gate.SetConnLoginReq set_conn_login_req = 13;
  bool has_set_conn_login_req() const;
  void clear_set_conn_login_req();
  static const int kSetConnLoginReqFieldNumber = 13;
  const ::gate::SetConnLoginReq& set_conn_login_req() const;
  ::gate::SetConnLoginReq* mutable_set_conn_login_req();
  ::gate::SetConnLoginReq* release_set_conn_login_req();
  void set_allocated_set_conn_login_req(::gate::SetConnLoginReq* set_conn_login_req);

  // .gate.SetConnLoginRsp set_conn_login_rsp = 14;
  bool has_set_conn_login_rsp() const;
  void clear_set_conn_login_rsp();
  static const int kSetConnLoginRspFieldNumber = 14;
  const ::gate::SetConnLoginRsp& set_conn_login_rsp() const;
  ::gate::SetConnLoginRsp* mutable_set_conn_login_rsp();
  ::gate::SetConnLoginRsp* release_set_conn_login_rsp();
  void set_allocated_set_conn_login_rsp(::gate::SetConnLoginRsp* set_conn_login_rsp);

  ChoiceCase choice_case() const;
  // @@protoc_insertion_point(class_scope:gate.GateMsg)
 private:
  void set_has_test_req();
  void set_has_test_rsp();
  void set_has_wake_heartbeat_req();
  void set_has_wake_heartbeat_rsp();
  void set_has_get_conn_id_req();
  void set_has_get_conn_id_rsp();
  void set_has_close_conn_id_req();
  void set_has_close_conn_id_rsp();
  void set_has_close_client_req();
  void set_has_close_client_rsp();
  void set_has_logout_req();
  void set_has_logout_rsp();
  void set_has_set_conn_login_req();
  void set_has_set_conn_login_rsp();

  inline bool has_choice() const;
  void clear_choice();
  inline void clear_has_choice();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ChoiceUnion {
    ChoiceUnion() {}
    ::common::TestReq* test_req_;
    ::common::TestRsp* test_rsp_;
    ::gate::WakeHeartbeatReq* wake_heartbeat_req_;
    ::gate::WakeHeartbeatRsp* wake_heartbeat_rsp_;
    ::gate::GetConnIdReq* get_conn_id_req_;
    ::gate::GetConnIdRsp* get_conn_id_rsp_;
    ::gate::CloseConnIdReq* close_conn_id_req_;
    ::gate::CloseConnIdRsp* close_conn_id_rsp_;
    ::gate::CloseClientReq* close_client_req_;
    ::gate::CloseClientRsp* close_client_rsp_;
    ::gate::LogoutReq* logout_req_;
    ::gate::LogoutRsp* logout_rsp_;
    ::gate::SetConnLoginReq* set_conn_login_req_;
    ::gate::SetConnLoginRsp* set_conn_login_rsp_;
  } choice_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WakeHeartbeatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.WakeHeartbeatReq) */ {
 public:
  WakeHeartbeatReq();
  virtual ~WakeHeartbeatReq();

  WakeHeartbeatReq(const WakeHeartbeatReq& from);

  inline WakeHeartbeatReq& operator=(const WakeHeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WakeHeartbeatReq(WakeHeartbeatReq&& from) noexcept
    : WakeHeartbeatReq() {
    *this = ::std::move(from);
  }

  inline WakeHeartbeatReq& operator=(WakeHeartbeatReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WakeHeartbeatReq& default_instance();

  static inline const WakeHeartbeatReq* internal_default_instance() {
    return reinterpret_cast<const WakeHeartbeatReq*>(
               &_WakeHeartbeatReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(WakeHeartbeatReq* other);
  friend void swap(WakeHeartbeatReq& a, WakeHeartbeatReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WakeHeartbeatReq* New() const PROTOBUF_FINAL { return New(NULL); }

  WakeHeartbeatReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WakeHeartbeatReq& from);
  void MergeFrom(const WakeHeartbeatReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WakeHeartbeatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 server_time = 1;
  void clear_server_time();
  static const int kServerTimeFieldNumber = 1;
  ::google::protobuf::uint64 server_time() const;
  void set_server_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gate.WakeHeartbeatReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 server_time_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WakeHeartbeatRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.WakeHeartbeatRsp) */ {
 public:
  WakeHeartbeatRsp();
  virtual ~WakeHeartbeatRsp();

  WakeHeartbeatRsp(const WakeHeartbeatRsp& from);

  inline WakeHeartbeatRsp& operator=(const WakeHeartbeatRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WakeHeartbeatRsp(WakeHeartbeatRsp&& from) noexcept
    : WakeHeartbeatRsp() {
    *this = ::std::move(from);
  }

  inline WakeHeartbeatRsp& operator=(WakeHeartbeatRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WakeHeartbeatRsp& default_instance();

  static inline const WakeHeartbeatRsp* internal_default_instance() {
    return reinterpret_cast<const WakeHeartbeatRsp*>(
               &_WakeHeartbeatRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(WakeHeartbeatRsp* other);
  friend void swap(WakeHeartbeatRsp& a, WakeHeartbeatRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WakeHeartbeatRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  WakeHeartbeatRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WakeHeartbeatRsp& from);
  void MergeFrom(const WakeHeartbeatRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WakeHeartbeatRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 client_time = 1;
  void clear_client_time();
  static const int kClientTimeFieldNumber = 1;
  ::google::protobuf::uint64 client_time() const;
  void set_client_time(::google::protobuf::uint64 value);

  // uint64 key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  ::google::protobuf::uint64 key() const;
  void set_key(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gate.WakeHeartbeatRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 client_time_;
  ::google::protobuf::uint64 key_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetConnIdReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GetConnIdReq) */ {
 public:
  GetConnIdReq();
  virtual ~GetConnIdReq();

  GetConnIdReq(const GetConnIdReq& from);

  inline GetConnIdReq& operator=(const GetConnIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetConnIdReq(GetConnIdReq&& from) noexcept
    : GetConnIdReq() {
    *this = ::std::move(from);
  }

  inline GetConnIdReq& operator=(GetConnIdReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConnIdReq& default_instance();

  static inline const GetConnIdReq* internal_default_instance() {
    return reinterpret_cast<const GetConnIdReq*>(
               &_GetConnIdReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(GetConnIdReq* other);
  friend void swap(GetConnIdReq& a, GetConnIdReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetConnIdReq* New() const PROTOBUF_FINAL { return New(NULL); }

  GetConnIdReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetConnIdReq& from);
  void MergeFrom(const GetConnIdReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetConnIdReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 client_time = 1;
  void clear_client_time();
  static const int kClientTimeFieldNumber = 1;
  ::google::protobuf::uint64 client_time() const;
  void set_client_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gate.GetConnIdReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 client_time_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetConnIdRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.GetConnIdRsp) */ {
 public:
  GetConnIdRsp();
  virtual ~GetConnIdRsp();

  GetConnIdRsp(const GetConnIdRsp& from);

  inline GetConnIdRsp& operator=(const GetConnIdRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetConnIdRsp(GetConnIdRsp&& from) noexcept
    : GetConnIdRsp() {
    *this = ::std::move(from);
  }

  inline GetConnIdRsp& operator=(GetConnIdRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetConnIdRsp& default_instance();

  static inline const GetConnIdRsp* internal_default_instance() {
    return reinterpret_cast<const GetConnIdRsp*>(
               &_GetConnIdRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GetConnIdRsp* other);
  friend void swap(GetConnIdRsp& a, GetConnIdRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetConnIdRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  GetConnIdRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetConnIdRsp& from);
  void MergeFrom(const GetConnIdRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetConnIdRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 server_time = 1;
  void clear_server_time();
  static const int kServerTimeFieldNumber = 1;
  ::google::protobuf::uint64 server_time() const;
  void set_server_time(::google::protobuf::uint64 value);

  // uint64 conn_id = 3;
  void clear_conn_id();
  static const int kConnIdFieldNumber = 3;
  ::google::protobuf::uint64 conn_id() const;
  void set_conn_id(::google::protobuf::uint64 value);

  // uint32 conn_create_time = 2;
  void clear_conn_create_time();
  static const int kConnCreateTimeFieldNumber = 2;
  ::google::protobuf::uint32 conn_create_time() const;
  void set_conn_create_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:gate.GetConnIdRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 server_time_;
  ::google::protobuf::uint64 conn_id_;
  ::google::protobuf::uint32 conn_create_time_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseConnIdReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.CloseConnIdReq) */ {
 public:
  CloseConnIdReq();
  virtual ~CloseConnIdReq();

  CloseConnIdReq(const CloseConnIdReq& from);

  inline CloseConnIdReq& operator=(const CloseConnIdReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseConnIdReq(CloseConnIdReq&& from) noexcept
    : CloseConnIdReq() {
    *this = ::std::move(from);
  }

  inline CloseConnIdReq& operator=(CloseConnIdReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnIdReq& default_instance();

  static inline const CloseConnIdReq* internal_default_instance() {
    return reinterpret_cast<const CloseConnIdReq*>(
               &_CloseConnIdReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(CloseConnIdReq* other);
  friend void swap(CloseConnIdReq& a, CloseConnIdReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseConnIdReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseConnIdReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseConnIdReq& from);
  void MergeFrom(const CloseConnIdReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseConnIdReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 conn_id = 1;
  void clear_conn_id();
  static const int kConnIdFieldNumber = 1;
  ::google::protobuf::uint64 conn_id() const;
  void set_conn_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gate.CloseConnIdReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 conn_id_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseConnIdRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.CloseConnIdRsp) */ {
 public:
  CloseConnIdRsp();
  virtual ~CloseConnIdRsp();

  CloseConnIdRsp(const CloseConnIdRsp& from);

  inline CloseConnIdRsp& operator=(const CloseConnIdRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseConnIdRsp(CloseConnIdRsp&& from) noexcept
    : CloseConnIdRsp() {
    *this = ::std::move(from);
  }

  inline CloseConnIdRsp& operator=(CloseConnIdRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseConnIdRsp& default_instance();

  static inline const CloseConnIdRsp* internal_default_instance() {
    return reinterpret_cast<const CloseConnIdRsp*>(
               &_CloseConnIdRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(CloseConnIdRsp* other);
  friend void swap(CloseConnIdRsp& a, CloseConnIdRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseConnIdRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseConnIdRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseConnIdRsp& from);
  void MergeFrom(const CloseConnIdRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseConnIdRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.CloseConnIdRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseClientReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.CloseClientReq) */ {
 public:
  CloseClientReq();
  virtual ~CloseClientReq();

  CloseClientReq(const CloseClientReq& from);

  inline CloseClientReq& operator=(const CloseClientReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseClientReq(CloseClientReq&& from) noexcept
    : CloseClientReq() {
    *this = ::std::move(from);
  }

  inline CloseClientReq& operator=(CloseClientReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseClientReq& default_instance();

  static inline const CloseClientReq* internal_default_instance() {
    return reinterpret_cast<const CloseClientReq*>(
               &_CloseClientReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(CloseClientReq* other);
  friend void swap(CloseClientReq& a, CloseClientReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseClientReq* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseClientReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseClientReq& from);
  void MergeFrom(const CloseClientReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseClientReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.CloseClientReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CloseClientRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.CloseClientRsp) */ {
 public:
  CloseClientRsp();
  virtual ~CloseClientRsp();

  CloseClientRsp(const CloseClientRsp& from);

  inline CloseClientRsp& operator=(const CloseClientRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloseClientRsp(CloseClientRsp&& from) noexcept
    : CloseClientRsp() {
    *this = ::std::move(from);
  }

  inline CloseClientRsp& operator=(CloseClientRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseClientRsp& default_instance();

  static inline const CloseClientRsp* internal_default_instance() {
    return reinterpret_cast<const CloseClientRsp*>(
               &_CloseClientRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(CloseClientRsp* other);
  friend void swap(CloseClientRsp& a, CloseClientRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloseClientRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  CloseClientRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CloseClientRsp& from);
  void MergeFrom(const CloseClientRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CloseClientRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.CloseClientRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.LogoutReq) */ {
 public:
  LogoutReq();
  virtual ~LogoutReq();

  LogoutReq(const LogoutReq& from);

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogoutReq(LogoutReq&& from) noexcept
    : LogoutReq() {
    *this = ::std::move(from);
  }

  inline LogoutReq& operator=(LogoutReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutReq& default_instance();

  static inline const LogoutReq* internal_default_instance() {
    return reinterpret_cast<const LogoutReq*>(
               &_LogoutReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(LogoutReq* other);
  friend void swap(LogoutReq& a, LogoutReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutReq* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutReq& from);
  void MergeFrom(const LogoutReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.LogoutReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogoutRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.LogoutRsp) */ {
 public:
  LogoutRsp();
  virtual ~LogoutRsp();

  LogoutRsp(const LogoutRsp& from);

  inline LogoutRsp& operator=(const LogoutRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogoutRsp(LogoutRsp&& from) noexcept
    : LogoutRsp() {
    *this = ::std::move(from);
  }

  inline LogoutRsp& operator=(LogoutRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRsp& default_instance();

  static inline const LogoutRsp* internal_default_instance() {
    return reinterpret_cast<const LogoutRsp*>(
               &_LogoutRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(LogoutRsp* other);
  friend void swap(LogoutRsp& a, LogoutRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogoutRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  LogoutRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LogoutRsp& from);
  void MergeFrom(const LogoutRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LogoutRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.LogoutRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetConnLoginReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.SetConnLoginReq) */ {
 public:
  SetConnLoginReq();
  virtual ~SetConnLoginReq();

  SetConnLoginReq(const SetConnLoginReq& from);

  inline SetConnLoginReq& operator=(const SetConnLoginReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetConnLoginReq(SetConnLoginReq&& from) noexcept
    : SetConnLoginReq() {
    *this = ::std::move(from);
  }

  inline SetConnLoginReq& operator=(SetConnLoginReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetConnLoginReq& default_instance();

  static inline const SetConnLoginReq* internal_default_instance() {
    return reinterpret_cast<const SetConnLoginReq*>(
               &_SetConnLoginReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(SetConnLoginReq* other);
  friend void swap(SetConnLoginReq& a, SetConnLoginReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetConnLoginReq* New() const PROTOBUF_FINAL { return New(NULL); }

  SetConnLoginReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetConnLoginReq& from);
  void MergeFrom(const SetConnLoginReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetConnLoginReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 conn_id = 1;
  void clear_conn_id();
  static const int kConnIdFieldNumber = 1;
  ::google::protobuf::uint64 conn_id() const;
  void set_conn_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:gate.SetConnLoginReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 conn_id_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetConnLoginRsp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:gate.SetConnLoginRsp) */ {
 public:
  SetConnLoginRsp();
  virtual ~SetConnLoginRsp();

  SetConnLoginRsp(const SetConnLoginRsp& from);

  inline SetConnLoginRsp& operator=(const SetConnLoginRsp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetConnLoginRsp(SetConnLoginRsp&& from) noexcept
    : SetConnLoginRsp() {
    *this = ::std::move(from);
  }

  inline SetConnLoginRsp& operator=(SetConnLoginRsp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetConnLoginRsp& default_instance();

  static inline const SetConnLoginRsp* internal_default_instance() {
    return reinterpret_cast<const SetConnLoginRsp*>(
               &_SetConnLoginRsp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SetConnLoginRsp* other);
  friend void swap(SetConnLoginRsp& a, SetConnLoginRsp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetConnLoginRsp* New() const PROTOBUF_FINAL { return New(NULL); }

  SetConnLoginRsp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetConnLoginRsp& from);
  void MergeFrom(const SetConnLoginRsp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetConnLoginRsp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:gate.SetConnLoginRsp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_gate_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GateMsg

// .common.TestReq test_req = 1;
inline bool GateMsg::has_test_req() const {
  return choice_case() == kTestReq;
}
inline void GateMsg::set_has_test_req() {
  _oneof_case_[0] = kTestReq;
}
inline void GateMsg::clear_test_req() {
  if (has_test_req()) {
    delete choice_.test_req_;
    clear_has_choice();
  }
}
inline  const ::common::TestReq& GateMsg::test_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.test_req)
  return has_test_req()
      ? *choice_.test_req_
      : ::common::TestReq::default_instance();
}
inline ::common::TestReq* GateMsg::mutable_test_req() {
  if (!has_test_req()) {
    clear_choice();
    set_has_test_req();
    choice_.test_req_ = new ::common::TestReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.test_req)
  return choice_.test_req_;
}
inline ::common::TestReq* GateMsg::release_test_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.test_req)
  if (has_test_req()) {
    clear_has_choice();
    ::common::TestReq* temp = choice_.test_req_;
    choice_.test_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_test_req(::common::TestReq* test_req) {
  clear_choice();
  if (test_req) {
    set_has_test_req();
    choice_.test_req_ = test_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.test_req)
}

// .common.TestRsp test_rsp = 2;
inline bool GateMsg::has_test_rsp() const {
  return choice_case() == kTestRsp;
}
inline void GateMsg::set_has_test_rsp() {
  _oneof_case_[0] = kTestRsp;
}
inline void GateMsg::clear_test_rsp() {
  if (has_test_rsp()) {
    delete choice_.test_rsp_;
    clear_has_choice();
  }
}
inline  const ::common::TestRsp& GateMsg::test_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.test_rsp)
  return has_test_rsp()
      ? *choice_.test_rsp_
      : ::common::TestRsp::default_instance();
}
inline ::common::TestRsp* GateMsg::mutable_test_rsp() {
  if (!has_test_rsp()) {
    clear_choice();
    set_has_test_rsp();
    choice_.test_rsp_ = new ::common::TestRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.test_rsp)
  return choice_.test_rsp_;
}
inline ::common::TestRsp* GateMsg::release_test_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.test_rsp)
  if (has_test_rsp()) {
    clear_has_choice();
    ::common::TestRsp* temp = choice_.test_rsp_;
    choice_.test_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_test_rsp(::common::TestRsp* test_rsp) {
  clear_choice();
  if (test_rsp) {
    set_has_test_rsp();
    choice_.test_rsp_ = test_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.test_rsp)
}

// .gate.WakeHeartbeatReq wake_heartbeat_req = 3;
inline bool GateMsg::has_wake_heartbeat_req() const {
  return choice_case() == kWakeHeartbeatReq;
}
inline void GateMsg::set_has_wake_heartbeat_req() {
  _oneof_case_[0] = kWakeHeartbeatReq;
}
inline void GateMsg::clear_wake_heartbeat_req() {
  if (has_wake_heartbeat_req()) {
    delete choice_.wake_heartbeat_req_;
    clear_has_choice();
  }
}
inline  const ::gate::WakeHeartbeatReq& GateMsg::wake_heartbeat_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.wake_heartbeat_req)
  return has_wake_heartbeat_req()
      ? *choice_.wake_heartbeat_req_
      : ::gate::WakeHeartbeatReq::default_instance();
}
inline ::gate::WakeHeartbeatReq* GateMsg::mutable_wake_heartbeat_req() {
  if (!has_wake_heartbeat_req()) {
    clear_choice();
    set_has_wake_heartbeat_req();
    choice_.wake_heartbeat_req_ = new ::gate::WakeHeartbeatReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.wake_heartbeat_req)
  return choice_.wake_heartbeat_req_;
}
inline ::gate::WakeHeartbeatReq* GateMsg::release_wake_heartbeat_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.wake_heartbeat_req)
  if (has_wake_heartbeat_req()) {
    clear_has_choice();
    ::gate::WakeHeartbeatReq* temp = choice_.wake_heartbeat_req_;
    choice_.wake_heartbeat_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_wake_heartbeat_req(::gate::WakeHeartbeatReq* wake_heartbeat_req) {
  clear_choice();
  if (wake_heartbeat_req) {
    set_has_wake_heartbeat_req();
    choice_.wake_heartbeat_req_ = wake_heartbeat_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.wake_heartbeat_req)
}

// .gate.WakeHeartbeatRsp wake_heartbeat_rsp = 4;
inline bool GateMsg::has_wake_heartbeat_rsp() const {
  return choice_case() == kWakeHeartbeatRsp;
}
inline void GateMsg::set_has_wake_heartbeat_rsp() {
  _oneof_case_[0] = kWakeHeartbeatRsp;
}
inline void GateMsg::clear_wake_heartbeat_rsp() {
  if (has_wake_heartbeat_rsp()) {
    delete choice_.wake_heartbeat_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::WakeHeartbeatRsp& GateMsg::wake_heartbeat_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.wake_heartbeat_rsp)
  return has_wake_heartbeat_rsp()
      ? *choice_.wake_heartbeat_rsp_
      : ::gate::WakeHeartbeatRsp::default_instance();
}
inline ::gate::WakeHeartbeatRsp* GateMsg::mutable_wake_heartbeat_rsp() {
  if (!has_wake_heartbeat_rsp()) {
    clear_choice();
    set_has_wake_heartbeat_rsp();
    choice_.wake_heartbeat_rsp_ = new ::gate::WakeHeartbeatRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.wake_heartbeat_rsp)
  return choice_.wake_heartbeat_rsp_;
}
inline ::gate::WakeHeartbeatRsp* GateMsg::release_wake_heartbeat_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.wake_heartbeat_rsp)
  if (has_wake_heartbeat_rsp()) {
    clear_has_choice();
    ::gate::WakeHeartbeatRsp* temp = choice_.wake_heartbeat_rsp_;
    choice_.wake_heartbeat_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_wake_heartbeat_rsp(::gate::WakeHeartbeatRsp* wake_heartbeat_rsp) {
  clear_choice();
  if (wake_heartbeat_rsp) {
    set_has_wake_heartbeat_rsp();
    choice_.wake_heartbeat_rsp_ = wake_heartbeat_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.wake_heartbeat_rsp)
}

// .gate.GetConnIdReq get_conn_id_req = 5;
inline bool GateMsg::has_get_conn_id_req() const {
  return choice_case() == kGetConnIdReq;
}
inline void GateMsg::set_has_get_conn_id_req() {
  _oneof_case_[0] = kGetConnIdReq;
}
inline void GateMsg::clear_get_conn_id_req() {
  if (has_get_conn_id_req()) {
    delete choice_.get_conn_id_req_;
    clear_has_choice();
  }
}
inline  const ::gate::GetConnIdReq& GateMsg::get_conn_id_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.get_conn_id_req)
  return has_get_conn_id_req()
      ? *choice_.get_conn_id_req_
      : ::gate::GetConnIdReq::default_instance();
}
inline ::gate::GetConnIdReq* GateMsg::mutable_get_conn_id_req() {
  if (!has_get_conn_id_req()) {
    clear_choice();
    set_has_get_conn_id_req();
    choice_.get_conn_id_req_ = new ::gate::GetConnIdReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.get_conn_id_req)
  return choice_.get_conn_id_req_;
}
inline ::gate::GetConnIdReq* GateMsg::release_get_conn_id_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.get_conn_id_req)
  if (has_get_conn_id_req()) {
    clear_has_choice();
    ::gate::GetConnIdReq* temp = choice_.get_conn_id_req_;
    choice_.get_conn_id_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_get_conn_id_req(::gate::GetConnIdReq* get_conn_id_req) {
  clear_choice();
  if (get_conn_id_req) {
    set_has_get_conn_id_req();
    choice_.get_conn_id_req_ = get_conn_id_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.get_conn_id_req)
}

// .gate.GetConnIdRsp get_conn_id_rsp = 6;
inline bool GateMsg::has_get_conn_id_rsp() const {
  return choice_case() == kGetConnIdRsp;
}
inline void GateMsg::set_has_get_conn_id_rsp() {
  _oneof_case_[0] = kGetConnIdRsp;
}
inline void GateMsg::clear_get_conn_id_rsp() {
  if (has_get_conn_id_rsp()) {
    delete choice_.get_conn_id_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::GetConnIdRsp& GateMsg::get_conn_id_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.get_conn_id_rsp)
  return has_get_conn_id_rsp()
      ? *choice_.get_conn_id_rsp_
      : ::gate::GetConnIdRsp::default_instance();
}
inline ::gate::GetConnIdRsp* GateMsg::mutable_get_conn_id_rsp() {
  if (!has_get_conn_id_rsp()) {
    clear_choice();
    set_has_get_conn_id_rsp();
    choice_.get_conn_id_rsp_ = new ::gate::GetConnIdRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.get_conn_id_rsp)
  return choice_.get_conn_id_rsp_;
}
inline ::gate::GetConnIdRsp* GateMsg::release_get_conn_id_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.get_conn_id_rsp)
  if (has_get_conn_id_rsp()) {
    clear_has_choice();
    ::gate::GetConnIdRsp* temp = choice_.get_conn_id_rsp_;
    choice_.get_conn_id_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_get_conn_id_rsp(::gate::GetConnIdRsp* get_conn_id_rsp) {
  clear_choice();
  if (get_conn_id_rsp) {
    set_has_get_conn_id_rsp();
    choice_.get_conn_id_rsp_ = get_conn_id_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.get_conn_id_rsp)
}

// .gate.CloseConnIdReq close_conn_id_req = 7;
inline bool GateMsg::has_close_conn_id_req() const {
  return choice_case() == kCloseConnIdReq;
}
inline void GateMsg::set_has_close_conn_id_req() {
  _oneof_case_[0] = kCloseConnIdReq;
}
inline void GateMsg::clear_close_conn_id_req() {
  if (has_close_conn_id_req()) {
    delete choice_.close_conn_id_req_;
    clear_has_choice();
  }
}
inline  const ::gate::CloseConnIdReq& GateMsg::close_conn_id_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.close_conn_id_req)
  return has_close_conn_id_req()
      ? *choice_.close_conn_id_req_
      : ::gate::CloseConnIdReq::default_instance();
}
inline ::gate::CloseConnIdReq* GateMsg::mutable_close_conn_id_req() {
  if (!has_close_conn_id_req()) {
    clear_choice();
    set_has_close_conn_id_req();
    choice_.close_conn_id_req_ = new ::gate::CloseConnIdReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.close_conn_id_req)
  return choice_.close_conn_id_req_;
}
inline ::gate::CloseConnIdReq* GateMsg::release_close_conn_id_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.close_conn_id_req)
  if (has_close_conn_id_req()) {
    clear_has_choice();
    ::gate::CloseConnIdReq* temp = choice_.close_conn_id_req_;
    choice_.close_conn_id_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_close_conn_id_req(::gate::CloseConnIdReq* close_conn_id_req) {
  clear_choice();
  if (close_conn_id_req) {
    set_has_close_conn_id_req();
    choice_.close_conn_id_req_ = close_conn_id_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.close_conn_id_req)
}

// .gate.CloseConnIdRsp close_conn_id_rsp = 8;
inline bool GateMsg::has_close_conn_id_rsp() const {
  return choice_case() == kCloseConnIdRsp;
}
inline void GateMsg::set_has_close_conn_id_rsp() {
  _oneof_case_[0] = kCloseConnIdRsp;
}
inline void GateMsg::clear_close_conn_id_rsp() {
  if (has_close_conn_id_rsp()) {
    delete choice_.close_conn_id_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::CloseConnIdRsp& GateMsg::close_conn_id_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.close_conn_id_rsp)
  return has_close_conn_id_rsp()
      ? *choice_.close_conn_id_rsp_
      : ::gate::CloseConnIdRsp::default_instance();
}
inline ::gate::CloseConnIdRsp* GateMsg::mutable_close_conn_id_rsp() {
  if (!has_close_conn_id_rsp()) {
    clear_choice();
    set_has_close_conn_id_rsp();
    choice_.close_conn_id_rsp_ = new ::gate::CloseConnIdRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.close_conn_id_rsp)
  return choice_.close_conn_id_rsp_;
}
inline ::gate::CloseConnIdRsp* GateMsg::release_close_conn_id_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.close_conn_id_rsp)
  if (has_close_conn_id_rsp()) {
    clear_has_choice();
    ::gate::CloseConnIdRsp* temp = choice_.close_conn_id_rsp_;
    choice_.close_conn_id_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_close_conn_id_rsp(::gate::CloseConnIdRsp* close_conn_id_rsp) {
  clear_choice();
  if (close_conn_id_rsp) {
    set_has_close_conn_id_rsp();
    choice_.close_conn_id_rsp_ = close_conn_id_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.close_conn_id_rsp)
}

// .gate.CloseClientReq close_client_req = 9;
inline bool GateMsg::has_close_client_req() const {
  return choice_case() == kCloseClientReq;
}
inline void GateMsg::set_has_close_client_req() {
  _oneof_case_[0] = kCloseClientReq;
}
inline void GateMsg::clear_close_client_req() {
  if (has_close_client_req()) {
    delete choice_.close_client_req_;
    clear_has_choice();
  }
}
inline  const ::gate::CloseClientReq& GateMsg::close_client_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.close_client_req)
  return has_close_client_req()
      ? *choice_.close_client_req_
      : ::gate::CloseClientReq::default_instance();
}
inline ::gate::CloseClientReq* GateMsg::mutable_close_client_req() {
  if (!has_close_client_req()) {
    clear_choice();
    set_has_close_client_req();
    choice_.close_client_req_ = new ::gate::CloseClientReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.close_client_req)
  return choice_.close_client_req_;
}
inline ::gate::CloseClientReq* GateMsg::release_close_client_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.close_client_req)
  if (has_close_client_req()) {
    clear_has_choice();
    ::gate::CloseClientReq* temp = choice_.close_client_req_;
    choice_.close_client_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_close_client_req(::gate::CloseClientReq* close_client_req) {
  clear_choice();
  if (close_client_req) {
    set_has_close_client_req();
    choice_.close_client_req_ = close_client_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.close_client_req)
}

// .gate.CloseClientRsp close_client_rsp = 10;
inline bool GateMsg::has_close_client_rsp() const {
  return choice_case() == kCloseClientRsp;
}
inline void GateMsg::set_has_close_client_rsp() {
  _oneof_case_[0] = kCloseClientRsp;
}
inline void GateMsg::clear_close_client_rsp() {
  if (has_close_client_rsp()) {
    delete choice_.close_client_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::CloseClientRsp& GateMsg::close_client_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.close_client_rsp)
  return has_close_client_rsp()
      ? *choice_.close_client_rsp_
      : ::gate::CloseClientRsp::default_instance();
}
inline ::gate::CloseClientRsp* GateMsg::mutable_close_client_rsp() {
  if (!has_close_client_rsp()) {
    clear_choice();
    set_has_close_client_rsp();
    choice_.close_client_rsp_ = new ::gate::CloseClientRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.close_client_rsp)
  return choice_.close_client_rsp_;
}
inline ::gate::CloseClientRsp* GateMsg::release_close_client_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.close_client_rsp)
  if (has_close_client_rsp()) {
    clear_has_choice();
    ::gate::CloseClientRsp* temp = choice_.close_client_rsp_;
    choice_.close_client_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_close_client_rsp(::gate::CloseClientRsp* close_client_rsp) {
  clear_choice();
  if (close_client_rsp) {
    set_has_close_client_rsp();
    choice_.close_client_rsp_ = close_client_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.close_client_rsp)
}

// .gate.LogoutReq logout_req = 11;
inline bool GateMsg::has_logout_req() const {
  return choice_case() == kLogoutReq;
}
inline void GateMsg::set_has_logout_req() {
  _oneof_case_[0] = kLogoutReq;
}
inline void GateMsg::clear_logout_req() {
  if (has_logout_req()) {
    delete choice_.logout_req_;
    clear_has_choice();
  }
}
inline  const ::gate::LogoutReq& GateMsg::logout_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.logout_req)
  return has_logout_req()
      ? *choice_.logout_req_
      : ::gate::LogoutReq::default_instance();
}
inline ::gate::LogoutReq* GateMsg::mutable_logout_req() {
  if (!has_logout_req()) {
    clear_choice();
    set_has_logout_req();
    choice_.logout_req_ = new ::gate::LogoutReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.logout_req)
  return choice_.logout_req_;
}
inline ::gate::LogoutReq* GateMsg::release_logout_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.logout_req)
  if (has_logout_req()) {
    clear_has_choice();
    ::gate::LogoutReq* temp = choice_.logout_req_;
    choice_.logout_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_logout_req(::gate::LogoutReq* logout_req) {
  clear_choice();
  if (logout_req) {
    set_has_logout_req();
    choice_.logout_req_ = logout_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.logout_req)
}

// .gate.LogoutRsp logout_rsp = 12;
inline bool GateMsg::has_logout_rsp() const {
  return choice_case() == kLogoutRsp;
}
inline void GateMsg::set_has_logout_rsp() {
  _oneof_case_[0] = kLogoutRsp;
}
inline void GateMsg::clear_logout_rsp() {
  if (has_logout_rsp()) {
    delete choice_.logout_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::LogoutRsp& GateMsg::logout_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.logout_rsp)
  return has_logout_rsp()
      ? *choice_.logout_rsp_
      : ::gate::LogoutRsp::default_instance();
}
inline ::gate::LogoutRsp* GateMsg::mutable_logout_rsp() {
  if (!has_logout_rsp()) {
    clear_choice();
    set_has_logout_rsp();
    choice_.logout_rsp_ = new ::gate::LogoutRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.logout_rsp)
  return choice_.logout_rsp_;
}
inline ::gate::LogoutRsp* GateMsg::release_logout_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.logout_rsp)
  if (has_logout_rsp()) {
    clear_has_choice();
    ::gate::LogoutRsp* temp = choice_.logout_rsp_;
    choice_.logout_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_logout_rsp(::gate::LogoutRsp* logout_rsp) {
  clear_choice();
  if (logout_rsp) {
    set_has_logout_rsp();
    choice_.logout_rsp_ = logout_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.logout_rsp)
}

// .gate.SetConnLoginReq set_conn_login_req = 13;
inline bool GateMsg::has_set_conn_login_req() const {
  return choice_case() == kSetConnLoginReq;
}
inline void GateMsg::set_has_set_conn_login_req() {
  _oneof_case_[0] = kSetConnLoginReq;
}
inline void GateMsg::clear_set_conn_login_req() {
  if (has_set_conn_login_req()) {
    delete choice_.set_conn_login_req_;
    clear_has_choice();
  }
}
inline  const ::gate::SetConnLoginReq& GateMsg::set_conn_login_req() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.set_conn_login_req)
  return has_set_conn_login_req()
      ? *choice_.set_conn_login_req_
      : ::gate::SetConnLoginReq::default_instance();
}
inline ::gate::SetConnLoginReq* GateMsg::mutable_set_conn_login_req() {
  if (!has_set_conn_login_req()) {
    clear_choice();
    set_has_set_conn_login_req();
    choice_.set_conn_login_req_ = new ::gate::SetConnLoginReq;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.set_conn_login_req)
  return choice_.set_conn_login_req_;
}
inline ::gate::SetConnLoginReq* GateMsg::release_set_conn_login_req() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.set_conn_login_req)
  if (has_set_conn_login_req()) {
    clear_has_choice();
    ::gate::SetConnLoginReq* temp = choice_.set_conn_login_req_;
    choice_.set_conn_login_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_set_conn_login_req(::gate::SetConnLoginReq* set_conn_login_req) {
  clear_choice();
  if (set_conn_login_req) {
    set_has_set_conn_login_req();
    choice_.set_conn_login_req_ = set_conn_login_req;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.set_conn_login_req)
}

// .gate.SetConnLoginRsp set_conn_login_rsp = 14;
inline bool GateMsg::has_set_conn_login_rsp() const {
  return choice_case() == kSetConnLoginRsp;
}
inline void GateMsg::set_has_set_conn_login_rsp() {
  _oneof_case_[0] = kSetConnLoginRsp;
}
inline void GateMsg::clear_set_conn_login_rsp() {
  if (has_set_conn_login_rsp()) {
    delete choice_.set_conn_login_rsp_;
    clear_has_choice();
  }
}
inline  const ::gate::SetConnLoginRsp& GateMsg::set_conn_login_rsp() const {
  // @@protoc_insertion_point(field_get:gate.GateMsg.set_conn_login_rsp)
  return has_set_conn_login_rsp()
      ? *choice_.set_conn_login_rsp_
      : ::gate::SetConnLoginRsp::default_instance();
}
inline ::gate::SetConnLoginRsp* GateMsg::mutable_set_conn_login_rsp() {
  if (!has_set_conn_login_rsp()) {
    clear_choice();
    set_has_set_conn_login_rsp();
    choice_.set_conn_login_rsp_ = new ::gate::SetConnLoginRsp;
  }
  // @@protoc_insertion_point(field_mutable:gate.GateMsg.set_conn_login_rsp)
  return choice_.set_conn_login_rsp_;
}
inline ::gate::SetConnLoginRsp* GateMsg::release_set_conn_login_rsp() {
  // @@protoc_insertion_point(field_release:gate.GateMsg.set_conn_login_rsp)
  if (has_set_conn_login_rsp()) {
    clear_has_choice();
    ::gate::SetConnLoginRsp* temp = choice_.set_conn_login_rsp_;
    choice_.set_conn_login_rsp_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void GateMsg::set_allocated_set_conn_login_rsp(::gate::SetConnLoginRsp* set_conn_login_rsp) {
  clear_choice();
  if (set_conn_login_rsp) {
    set_has_set_conn_login_rsp();
    choice_.set_conn_login_rsp_ = set_conn_login_rsp;
  }
  // @@protoc_insertion_point(field_set_allocated:gate.GateMsg.set_conn_login_rsp)
}

inline bool GateMsg::has_choice() const {
  return choice_case() != CHOICE_NOT_SET;
}
inline void GateMsg::clear_has_choice() {
  _oneof_case_[0] = CHOICE_NOT_SET;
}
inline GateMsg::ChoiceCase GateMsg::choice_case() const {
  return GateMsg::ChoiceCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WakeHeartbeatReq

// uint64 server_time = 1;
inline void WakeHeartbeatReq::clear_server_time() {
  server_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WakeHeartbeatReq::server_time() const {
  // @@protoc_insertion_point(field_get:gate.WakeHeartbeatReq.server_time)
  return server_time_;
}
inline void WakeHeartbeatReq::set_server_time(::google::protobuf::uint64 value) {
  
  server_time_ = value;
  // @@protoc_insertion_point(field_set:gate.WakeHeartbeatReq.server_time)
}

// -------------------------------------------------------------------

// WakeHeartbeatRsp

// uint64 client_time = 1;
inline void WakeHeartbeatRsp::clear_client_time() {
  client_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WakeHeartbeatRsp::client_time() const {
  // @@protoc_insertion_point(field_get:gate.WakeHeartbeatRsp.client_time)
  return client_time_;
}
inline void WakeHeartbeatRsp::set_client_time(::google::protobuf::uint64 value) {
  
  client_time_ = value;
  // @@protoc_insertion_point(field_set:gate.WakeHeartbeatRsp.client_time)
}

// uint64 key = 2;
inline void WakeHeartbeatRsp::clear_key() {
  key_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WakeHeartbeatRsp::key() const {
  // @@protoc_insertion_point(field_get:gate.WakeHeartbeatRsp.key)
  return key_;
}
inline void WakeHeartbeatRsp::set_key(::google::protobuf::uint64 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:gate.WakeHeartbeatRsp.key)
}

// -------------------------------------------------------------------

// GetConnIdReq

// uint64 client_time = 1;
inline void GetConnIdReq::clear_client_time() {
  client_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetConnIdReq::client_time() const {
  // @@protoc_insertion_point(field_get:gate.GetConnIdReq.client_time)
  return client_time_;
}
inline void GetConnIdReq::set_client_time(::google::protobuf::uint64 value) {
  
  client_time_ = value;
  // @@protoc_insertion_point(field_set:gate.GetConnIdReq.client_time)
}

// -------------------------------------------------------------------

// GetConnIdRsp

// uint64 server_time = 1;
inline void GetConnIdRsp::clear_server_time() {
  server_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetConnIdRsp::server_time() const {
  // @@protoc_insertion_point(field_get:gate.GetConnIdRsp.server_time)
  return server_time_;
}
inline void GetConnIdRsp::set_server_time(::google::protobuf::uint64 value) {
  
  server_time_ = value;
  // @@protoc_insertion_point(field_set:gate.GetConnIdRsp.server_time)
}

// uint32 conn_create_time = 2;
inline void GetConnIdRsp::clear_conn_create_time() {
  conn_create_time_ = 0u;
}
inline ::google::protobuf::uint32 GetConnIdRsp::conn_create_time() const {
  // @@protoc_insertion_point(field_get:gate.GetConnIdRsp.conn_create_time)
  return conn_create_time_;
}
inline void GetConnIdRsp::set_conn_create_time(::google::protobuf::uint32 value) {
  
  conn_create_time_ = value;
  // @@protoc_insertion_point(field_set:gate.GetConnIdRsp.conn_create_time)
}

// uint64 conn_id = 3;
inline void GetConnIdRsp::clear_conn_id() {
  conn_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 GetConnIdRsp::conn_id() const {
  // @@protoc_insertion_point(field_get:gate.GetConnIdRsp.conn_id)
  return conn_id_;
}
inline void GetConnIdRsp::set_conn_id(::google::protobuf::uint64 value) {
  
  conn_id_ = value;
  // @@protoc_insertion_point(field_set:gate.GetConnIdRsp.conn_id)
}

// -------------------------------------------------------------------

// CloseConnIdReq

// uint64 conn_id = 1;
inline void CloseConnIdReq::clear_conn_id() {
  conn_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 CloseConnIdReq::conn_id() const {
  // @@protoc_insertion_point(field_get:gate.CloseConnIdReq.conn_id)
  return conn_id_;
}
inline void CloseConnIdReq::set_conn_id(::google::protobuf::uint64 value) {
  
  conn_id_ = value;
  // @@protoc_insertion_point(field_set:gate.CloseConnIdReq.conn_id)
}

// -------------------------------------------------------------------

// CloseConnIdRsp

// -------------------------------------------------------------------

// CloseClientReq

// -------------------------------------------------------------------

// CloseClientRsp

// -------------------------------------------------------------------

// LogoutReq

// -------------------------------------------------------------------

// LogoutRsp

// -------------------------------------------------------------------

// SetConnLoginReq

// uint64 conn_id = 1;
inline void SetConnLoginReq::clear_conn_id() {
  conn_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 SetConnLoginReq::conn_id() const {
  // @@protoc_insertion_point(field_get:gate.SetConnLoginReq.conn_id)
  return conn_id_;
}
inline void SetConnLoginReq::set_conn_id(::google::protobuf::uint64 value) {
  
  conn_id_ = value;
  // @@protoc_insertion_point(field_set:gate.SetConnLoginReq.conn_id)
}

// -------------------------------------------------------------------

// SetConnLoginRsp

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace gate

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::gate::ErrorCode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::gate::ErrorCode>() {
  return ::gate::ErrorCode_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gate_2eproto__INCLUDED
